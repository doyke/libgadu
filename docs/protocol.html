<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
<head>
<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<style type="text/css">
body { font-family: tahoma, verdana, arial, helvetica, sans-serif; }
.tab { background-color: #a0a0a0; }
.tabh { background-color: #d0d0d0; }
.tabf { background-color: white; }
.tabf2 { background-color: white; color: silver; }
.check { background-color: white; color: silver; }
.warn { font-family: monospace; padding: 0.7em; background-color: red; border: 1px solid #80a0a0; }
.c { font-family: monospace; padding: 0.7em; background-color: #e0e0e0; border: 1px solid #a0a0a0; }
.http { font-family: monospace; padding: 0.7em; background-color: #c0f0c0; border: 1px solid #80a080; }
.example { font-family: monospace; padding: 0.7em; background-color: #c0f0f0; border: 1px solid #80a0a0; }
pre { margin: 0px; }
</style>
<title>Protokół Gadu-Gadu</title>
</head>

<body bgcolor="white" text="black">

<center>
<table width="600" border="0"><tr><td>

<center>
<h1>Protokół Gadu-Gadu</h1>
<h3>&copy; Copyright 2001-2009 <a href="#ch4">Autorzy</a></h3>
</center>

<hr />

<a name="index"></a>

<h2>Spis treści</h2>

<ol>
	<li><a href="#ch1">Protokół Gadu-Gadu</a><br />
		1.1.&nbsp;&nbsp;<a href="#ch1.1">Format pakietów i konwencje</a><br />
		1.2.&nbsp;&nbsp;<a href="#ch1.2">Zanim się połączymy</a><br />
		1.3.&nbsp;&nbsp;<a href="#ch1.3">Logowanie się</a><br />
		1.4.&nbsp;&nbsp;<a href="#ch1.4">Zmiana stanu</a><br />
		1.5.&nbsp;&nbsp;<a href="#ch1.5">Ludzie przychodzą, ludzie odchodzą</a><br />
		1.6.&nbsp;&nbsp;<a href="#ch1.6">Wysyłanie wiadomości</a><br />
		1.7.&nbsp;&nbsp;<a href="#ch1.7">Otrzymywanie wiadomości</a><br />
		1.8.&nbsp;&nbsp;<a href="#ch1.8">Ping, pong</a><br />
		1.9.&nbsp;&nbsp;<a href="#ch1.9">Rozłączenie</a><br />
		1.10.&nbsp;&nbsp;<a href="#ch1.10">Wiadomości systemowe</a><br />
		1.11.&nbsp;&nbsp;<a href="#ch1.11">Wiadomości GGLive</a><br />
		1.12.&nbsp;&nbsp;<a href="#ch1.12">Katalog publiczny</a><br />
		1.13.&nbsp;&nbsp;<a href="#ch1.13">Lista kontaktów</a><br />
		1.14.&nbsp;&nbsp;<a href="#ch1.14">Indeks pakietów</a><br />
	</li>
	<li><a href="#ch2">Usługi HTTP</a><br />
		2.1.&nbsp;&nbsp;<a href="#ch2.1">Format danych</a><br />
		2.2.&nbsp;&nbsp;<a href="#ch2.2">Tokeny</a><br />
		2.3.&nbsp;&nbsp;<a href="#ch2.3">Rejestracja konta</a><br />
		2.4.&nbsp;&nbsp;<a href="#ch2.4">Usunięcie konta</a><br />
		2.5.&nbsp;&nbsp;<a href="#ch2.5">Zmiana hasła</a><br />
		2.6.&nbsp;&nbsp;<a href="#ch2.6">Przypomnienie hasła pocztą</a><br />
	</li>
	<li><a href="#ch3">Połączenia bezpośrednie</a><br />
		3.1.&nbsp;&nbsp;<a href="#ch3.1">Nawiązanie połączenia</a><br />
		3.2.&nbsp;&nbsp;<a href="#ch3.2">Przesyłanie plików</a><br />
		3.3.&nbsp;&nbsp;<a href="#ch3.3">Rozmowy głosowe</a><br />
	</li>
	<li><a href="#ch4">Autorzy</a></li>
</ol>

<hr />

<a name="ch0"></a>
<h2>Informacje wstępne</h2>

<p>
Opis protokołu używanego przez Gadu-Gadu bazuje na doświadczeniach
przeprowadzonych przez autorów oraz informacjach nadsyłanych przez 
użytkowników. Żaden klient Gadu-Gadu nie został skrzywdzony podczas
badań. Reverse-engineering opierał się głównie na analizie pakietów
przesyłanych między klientem a serwerem.
</p>

<p>
Najnowsza wersja opisu protokołu znajduje się pod adresem
<a href="http://toxygen.net/libgadu/protocol/">http://toxygen.net/libgadu/protocol/</a>.
</p>

<hr />

<a name="ch1"></a>
<h2>1. Protokół Gadu-Gadu</h2>

<a name="ch1.1"></a>
<h3>1.1. Format pakietów i konwencje</h3>

<p>
Podobnie jak coraz większa ilość komunikatorów, Gadu-Gadu korzysta z
protokołu TCP/IP. Każdy pakiet zawiera na początku dwa stałe pola:
</p>

<div class="c">
<pre>struct gg_header {
	int type;	<i>/* typ pakietu */</i>
	int length;	<i>/* długość reszty pakietu */</i>
};</pre>
</div>

<p>
Wszystkie zmienne liczbowe są zgodne z kolejnością bajtów maszyn Intela,
czyli Little-Endian. Wszystkie teksty są kodowane przy użyciu zestawu
znaków UTF-8, chyba że zaznaczono inaczej. Linie kończą się znakami
<tt>\r\n</tt>.
</p>

<p>
Przy opisie struktur, założono, że <tt>char</tt> ma rozmiar 1 bajtu,
<tt>short</tt> 2 bajtów, <tt>int</tt> 4 bajtów, <tt>long long</tt> 8 bajtów,
wszystkie bez znaku. Używając architektur innych niż i386, należy zwrócić
szczególną uwagę na rozmiar typów zmiennych i kolejność bajtów. Poza tym,
większość dostępnych obecnie kompilatorów domyślnie wyrównuje zmienne do
rozmiaru słowa danej architektury, więc należy wyłączyć tą funkcję. W przypadku
gcc będzie to <tt>__attribute__ ((packed))</tt> zaraz za deklaracją każdej
struktury, a dla Microsoft Visual C++ powinno pomóc: </p>

<div class="c">
<pre>#pragma pack(push, 1)

<i>/* deklaracje */</i>

#pragma pack(pop)</pre>
</div>

<p>
Pola, których znaczenie jest nieznane, lub nie do końca jasne, oznaczono
przedrostkiem <tt>unknown</tt>.
</p>

<hr />

<a name="ch1.2"></a>
<h3>1.2. Zanim się połączymy</h3>

<p>
Żeby wiedzieć, z jakim serwerem mamy się połączyć, należy za pomocą HTTP
połączyć się z <tt>appmsg.gadu-gadu.pl</tt> i wysłać:
</p>

<div class="http">
<pre>GET /appsvc/appmsg_ver8.asp?fmnumber=<b>NUMER</b>&amp;fmt=<b>FORMAT</b>&amp;lastmsg=<b>WIADOMOŚĆ</b>&amp;version=<b>WERSJA</b> HTTP/1.1
Connection: Keep-Alive
Host: appmsg.gadu-gadu.pl</pre>
</div>

<p>
Gdzie:
</p>

<ul>
<li><b>NUMER</b> jest numerem Gadu-Gadu.</li>
<li><b>WERSJA</b> jest wersją klienta w postaci &bdquo;<tt>A.B.C.D</tt>&rdquo;
(na przykład &bdquo;<tt>8.0.0.7669</tt>&rdquo;).</li>
<li><b>FORMAT</b> określa czy wiadomość systemowa będzie przesyłana czystym
tekstem (brak zmiennej &bdquo;fmt&rdquo;) czy w HTMLu (wartość &bdquo;<tt>2</tt>&rdquo;).</li>
<li><b>WIADOMOŚĆ</b> jest numerem ostatnio otrzymanej wiadomości systemowej.</li>
</ul>

<p>
Na postawione w ten sposób zapytanie, serwer może odpowiedzieć w następujący
sposób:
</p>

<div class="example">
<pre>HTTP/1.0 200 OK
Connection: close

0 0 91.197.13.78:8074 91.197.13.78</pre>
</div>

<p>
Pierwsze pole jest numerem wiadomości systemowej, a trzecie i czwarte
podają nam namiary na właściwy serwer. Jeśli serwer jest niedostępny,
zamiast adresu IP jest zwracany tekst &bdquo;<tt>notoperating</tt>&rdquo;.
Jeżeli połączenie z portem 8074 nie powiedzie się z jakichś powodów,
można się łączyć na port 443. 
</p>

<p>
Jeśli pierwsza liczba jest różna od zera, zaraz po nagłówku znajduje się
wiadomość systemowa w wybranym formacie, lub jeśli linia zaczyna się od znaku
&bdquo;<tt>@</tt>&rdquo;, adres strony, którą należy otworzyć w przeglądarce.
</p>

<div class="http">
<pre>GET /appsvc/appmsg3.asp?fmnumber=<b>NUMER</b>&amp;version=<b>WERSJA</b>&amp;fmt=<b>FORMAT</b>&amp;lastmsg=<b>WIADOMOŚĆ</b>
Host: appmsg.gadu-gadu.pl
User-Agent: <b>PRZEGLĄDARKA</b>
Pragma: no-cache</pre>
</div>

<hr />

<a name="ch1.3"></a>
<h3>1.3. Logowanie się</h3>

<p>
Po połączeniu się portem 8074 lub 443 serwera Gadu-Gadu, otrzymujemy pakiet
typu <tt>0x0001</tt>, który na potrzeby tego dokumentu nazwiemy:
</p>

<div class="c">
<pre>#define GG_WELCOME 0x0001</pre>
</div>

<p>
Reszta pakietu zawiera ziarno &mdash; wartość, którą razem z hasłem przekazuje
się do funkcji skrótu:
</p>

<div class="c">
<pre>struct gg_welcome {
	int seed;	<i>/* ziarno */</i>
};</pre>
</div>

<p>
Kiedy mamy już tą wartość możemy odesłać pakiet logowania:
</p>

<div class="c">
<pre>#define GG_LOGIN80 0x0031

struct gg_login80 {
        int uin;              <i>/* numer Gadu-Gadu */</i>
        char language[2];     <i>/* język: "pl" */</i>
        char hash_type;       <i>/* rodzaj funkcji skrótu hasła */</i>
        char hash[64];        <i>/* skrót hasła dopełniony \0 */</i>
        int status;           <i>/* początkowy status połączenia */</i>
        int flags;            <i>/* flagi (przeznaczenie nieznane) */</i>
        int features;         <i>/* opcje protokołu (0x00000007)*/</i>
        int local_ip;         <i>/* lokalny adres połączeń bezpośrednich (nieużywany) */</i>
        short local_port;     <i>/* lokalny port połączeń bezpośrednich (nieużywany) */</i>
        int external_ip;      <i>/* zewnętrzny adres (nieużywany) */</i>
        short external_port;  <i>/* zewnętrzny port (nieużywany) */</i>
        char image_size;      <i>/* maksymalny rozmiar grafiki w KB */</i>
        char unknown2;        <i>/* 0x64 */</i>
        int version_len;      <i>/* długość ciągu z wersją (0x21) */</i>
        char version[];       <i>/* "Gadu-Gadu Client build 8.0.0.7669" (bez \0) */</i>
        int description_size; <i>/* rozmiar opisu */</i>
        char description[];   <i>/* opis (nie musi wystąpić, bez \0) */</i>
};</pre>

</div>

<p>
Pola określające adresy i port są pozostałościami po poprzednich wersjach
protokołów i w obecnej wersji zawierają zera. Pole z flagami jest przekazywane
innym kontaktom, ale jego znaczenie nie jest jeszcze znane. Ustalono jedynie,
że wartość <tt>0x00100000</tt> powoduje wyświetlenie ikony telefonu komórkowego
na liście kontaktów. Pole opcji protokołu zawsze zawiera wartość
<tt>0x00000007</tt> i jest mapą bitową:</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Bit</b></td><td><b>Wartość</b></td><td><b>Znaczenie</b></td></tr>
<tr class="tabf"><td>0</td><td><tt>0x00000001</tt></td><td>Rodzaj pakietu informującego o zmianie stanu kontaktów (patrz bit 2)<br /><tt>0</tt> &mdash; <tt>GG_STATUS77</tt>, <tt>GG_NOTIFY_REPLY77</tt><br /><tt>1</tt> &mdash; <tt>GG_STATUS80BETA</tt>, <tt>GG_NOTIFY_REPLY80BETA</tt></td></tr>
<tr class="tabf"><td>1</td><td><tt>0x00000002</tt></td><td>Rodzaj pakietu z otrzymają wiadomością<br /><tt>0</tt> &mdash; <tt>GG_RECV_MSG</tt><br /><tt>1</tt> &mdash; <tt>GG_RECV_MSG80</tt></td></tr>
<tr class="tabf"><td>2</td><td><tt>0x00000004</tt></td><td>Rodzaj pakietu informującego o zmianie stanu kontaktów (patrz bit 0)<br /><tt>0</tt> &mdash; wybrany przez bit 0<br /><tt>1</tt> &mdash; <tt>GG_STATUS80</tt>, <tt>GG_NOTIFY_REPLY80</tt></td></tr>
</table>

<p>
Skrót hasła można liczyć na dwa sposoby:
</p>

<div class="c">
<pre>#define GG_LOGIN_HASH_GG32 0x01
#define GG_LOGIN_HASH_SHA1 0x02</pre>
</div>

<p>
Pierwszy algorytm (<tt>GG_LOGIN_HASH_GG32</tt>) został wymyślony na potrzeby
Gadu-Gadu i zwraca 32-bitową wartość dla danego ziarna i hasła. Jego
implementacja w języku C wygląda następująco:
</p>

<div class="c">
<pre>int gg_login_hash(unsigned char *password, unsigned int seed)
{
	unsigned int x, y, z;

	y = seed;

	for (x = 0; *password; password++) {
		x = (x &amp; 0xffffff00) | *password;
		y ^= x;
		y += x;
		x &lt;&lt;= 8;
		y ^= x;
		x &lt;&lt;= 8;
		y -= x;
		x &lt;&lt;= 8;
		y ^= x;

		z = y &amp; 0x1f;
		y = (y &lt;&lt; z) | (y &gt;&gt; (32 - z));
	}

	return y;
}</pre>
</div>

<p>
Ze względu na niewielki zakres wartości wyjściowych, istnieje
prawdopodobieństwo, że inne hasło przy odpowiednim ziarnie da taki sam wynik.
Z tego powodu zalecane jest używane algorytmu
<a href="http://pl.wikipedia.org/wiki/SHA-1">SHA-1</a>, którego implementacje
są dostępne dla większości współczesnych systemów operacyjnych. Skrót SHA-1
należy obliczyć z połączenia hasła (bez <tt>\0</tt>) i binarnej reprezentacji
ziarna. Przykładowy kod może wyglądać w następujący sposób:
</p>

<div class="c">
<pre>char *gg_sha_hash(char *password, unsigned int seed)
{
	SHA1_CTX ctx;
	static char result[20];
	  
	SHA1_Init(&amp;ctx);  
	SHA1_Update(&amp;ctx, password, strlen(password));
	SHA1_Update(&amp;ctx, &amp;seed, sizeof(seed));
	SHA1_Final(result, &amp;ctx);

	return result;
}</pre>
</div>

<p>
Jeśli autoryzacja się powiedzie, dostaniemy w odpowiedzi pakiet:
</p>

<div class="c">
<pre>#define GG_LOGIN80_OK 0x0035

struct gg_login80_ok {
	int unknown1;	<i>/* 01 00 00 00 */</i>
};</pre>
</div>

<p>
W przypadku błędu autoryzacji otrzymamy pusty pakiet:
</p>

<div class="c">
<pre>#define GG_LOGIN_FAILED 0x0009</pre>
</div>

<hr />

<a name="ch1.4"></a>
<h3>1.4. Zmiana stanu</h3>

<p>
Gadu-Gadu przewiduje kilka stanów klienta, które zmieniamy pakietem typu:
</p>

<div class="c">
<pre>#define GG_NEW_STATUS80 0x0038
	
struct gg_new_status80 {
	int status;		<i>/* na jaki zmienić? */</i>
	int flags;              <i>/* flagi (nieznane przeznaczenie) */</i>
	int description_size;   <i>/* rozmiar opisu */</i>
	char description[];	<i>/* opis (nie musi wystąpić, bez \0) */</i>
}</pre>
</div>

<p>
Możliwe stany to:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Etykieta</b></td><td><b>Wartość</b></td><td><b>Znaczenie</b></td></tr>
<tr class="tabf"><td><tt>GG_STATUS_NOT_AVAIL</tt></td><td><tt>0x0001</tt></td><td>Niedostępny</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_NOT_AVAIL_DESCR</tt></td><td><tt>0x0015</tt></td><td>Niedostępny (z opisem)</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_FFC</tt></td><td><tt>0x0017</tt></td><td>PoGGadaj ze mną</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_FFC_DESCR</tt></td><td><tt>0x0018</tt></td><td>PoGGadaj ze mną (z opisem)</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_AVAIL</tt></td><td><tt>0x0002</tt></td><td>Dostępny</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_AVAIL_DESCR</tt></td><td><tt>0x0004</tt></td><td>Dostępny (z opisem)</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_BUSY</tt></td><td><tt>0x0003</tt></td><td>Zajęty</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_BUSY_DESCR</tt></td><td><tt>0x0005</tt></td><td>Zajęty (z opisem)</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_DND</tt></td><td><tt>0x0021</tt></td><td>Nie przeszkadzać</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_DND_DESCR</tt></td><td><tt>0x0022</tt></td><td>Nie przeszkadzać (z opisem)</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_INVISIBLE</tt></td><td><tt>0x0014</tt></td><td>Niewidoczny</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_INVISIBLE_DESCR</tt></td><td><tt>0x0016</tt></td><td>Niewidoczny z opisem</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_BLOCKED</tt></td><td><tt>0x0006</tt></td><td>Zablokowany</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_FRIENDS_MASK</tt></td><td><tt>0x8000</tt></td><td>Maska bitowa oznaczająca tryb tylko dla przyjaciół</td></tr>
</table>

<p>
Należy pamiętać, żeby przed rozłączeniem się z serwerem należy zmienić
stan na <tt>GG_STATUS_NOT_AVAIL</tt> lub <tt>GG_STATUS_NOT_AVAIL_DESCR</tt>.
Jeśli ma być widoczny tylko dla przyjaciół, należy dodać
<tt>GG_STATUS_FRIENDS_MASK</tt> do normalnej wartości stanu.
</p>

<p>
Maksymalna długość opisu wynosi 255 bajtów, jednak należy pamiętać że znak w UTF-8
czasami zajmuje więcej niż 1 bajt.
</p>

<hr />

<a name="ch1.5"></a>
<h3>1.5. Ludzie przychodzą, ludzie odchodzą</h3>

<p>
Zaraz po zalogowaniu możemy wysłać serwerowi naszą listę kontaktów, żeby
dowiedzieć się, czy są w danej chwili dostępni. Lista kontaktów jest dzielona
na pakiety po 400 wpisów. Pierwsze wpisy są typu <tt>GG_NOTIFY_FIRST</tt>,
a ostatni typu <tt>GG_NOTIFY_LAST</tt>, żeby serwer wiedział, kiedy kończymy.
Jeśli lista kontaktów jest mniejsza niż 400 wpisów, wysyłamy oczywiście tylko
<tt>GG_NOTIFY_LAST</tt>. Pakiety te zawierają struktury <tt>gg_notify</tt>:
</p>

<div class="c">
<pre>#define GG_NOTIFY_FIRST 0x000f
#define GG_NOTIFY_LAST 0x0010
	
struct gg_notify {
	int uin;	<i>/* numer Gadu-Gadu kontaktu */</i>
	char type;	<i>/* rodzaj użytkownika */</i>
};</pre>	
</div>

<p>
Gdzie pole <tt>type</tt> jest mapą bitową następujących wartości:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Etykieta</b></td><td><b>Wartość</b></td><td><b>Znaczenie</b></td></tr>
<tr class="tabf"><td><tt>GG_USER_BUDDY</tt></td><td><tt>0x01</tt></td><td>Każdy użytkownik dodany do listy kontaktów</td></tr>
<tr class="tabf"><td><tt>GG_USER_FRIEND</tt></td><td><tt>0x02</tt></td><td>Użytkownik, dla którego jesteśmy widoczni w trybie &bdquo;tylko dla przyjaciół&rdquo;</td></tr>
<tr class="tabf"><td><tt>GG_USER_BLOCKED</tt></td><td><tt>0x04</tt></td><td>Użytkownik, którego wiadomości nie chcemy otrzymywać</td></tr>
</table>

<p>
Jednak dla zachowania starego nazewnictwa stałych można używać najczęściej spotykane wartości to:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Etykieta</b></td><td><b>Wartość</b></td><td><b>Znaczenie</b></td></tr>
<tr class="tabf"><td><tt>GG_USER_OFFLINE</tt></td><td><tt>0x01</tt></td><td>Użytkownik, dla którego będziemy niedostępni, ale mamy go w liście kontaktów</td></tr>
<tr class="tabf"><td><tt>GG_USER_NORMAL</tt></td><td><tt>0x03</tt></td><td>Zwykły użytkownik dodany do listy kontaktów</td></tr>
<tr class="tabf"><td><tt>GG_USER_BLOCKED</tt></td><td><tt>0x04</tt></td><td>Użytkownik, którego wiadomości nie chcemy otrzymywać</td></tr>
</table>

<p>
Jeśli nie mamy nikogo na liście wysyłamy następujący pakiet o zerowej długości:
</p>

<div class="c">
<pre>#define GG_LIST_EMPTY 0x0012</pre>
</div>

<p>
Jeśli ktoś jest, serwer odpowie pakietem <tt>GG_NOTIFY_REPLY80</tt>
zawierającym jedną lub więcej struktur <tt>gg_notify_reply80</tt>:
</p>

<div class="c">
<pre>#define GG_NOTIFY_REPLY80 0x37
	
struct gg_notify_reply80 {
	int uin;		<i>/* numer Gadu-Gadu kontaktu */</i>
	int status;		<i>/* status */</i>
	int flags;		<i>/* flagi (nieznane przeznaczenie) */</i>
	int remote_ip;		<i>/* adres IP bezpośrednich połączeń (nieużywane) */</i>
	short remote_port;	<i>/* port bezpośrednich połączeń (nieużywane) */</i>
	char image_size;	<i>/* maksymalny rozmiar obrazków w KB */</i>
	char unknown2;		<i>/* 0x00 */</i>
	int unknown3;		<i>/* 0x00000000 */</i>
	int description_size;	<i>/* rozmiar opisu */</i>
	char description[];	<i>/* opis (nie musi wystąpić, bez \0) */</i>
};</pre>
</div>

<p>
Zdarzają się też inne &bdquo;nietypowe&rdquo; wartości, ale ich znaczenie nie
jest jeszcze do końca znane.
</p>

<p>
Aby dodać do listy kontaktów numer w trakcie połączenia, należy wysłać niżej
opisany pakiet. Jego format jest identyczny jak <tt>GG_NOTIFY_*</tt>, z tą
różnicą, że zawiera jeden numer.
</p>

<div class="c">
<pre>#define GG_ADD_NOTIFY 0x000d
	
struct gg_add_notify {
	int uin;	<i>/* numerek */</i>
	char type;	<i>/* rodzaj użytkownika */</i>
};</pre>
</div>

<p>
Poniższy pakiet usuwa z listy kontaktów:
</p>

<div class="c">
<pre>#define GG_REMOVE_NOTIFY 0x000e
	
struct gg_remove_notify {
	int uin;	<i>/* numerek */</i>
	char type;	<i>/* rodzaj użytkownika */</i>
};</pre>
</div>

<p>
Należy zwrócić uwagę, że pakiety <tt>GG_ADD_NOTIFY</tt>
i <tt>GG_REMOVE_NOTIFY</tt> dodają i usuwają flagi będące mapą bitową. Aby
zmienić status użytkownika z normalnego na blokowanego, należy najpierw
usunąć rodzaj <tt>GG_USER_NORMAL</tt>, a następnie dodać rodzaj 
<tt>GG_USER_BLOCKED</tt>.
</p>

<p>
Jeśli ktoś opuści Gadu-Gadu lub zmieni stan, otrzymamy poniższy pakiet,
którego struktura jest identyczna z <tt>GG_NOTIFY_REPLY80</tt>.
</p>

<div class="c">
<pre>#define GG_STATUS80 0x0036</pre>
</div>

<hr />

<a name="ch1.6"></a>
<h3>1.6. Wysyłanie wiadomości</h3>

<p>
Wiadomości wysyła się następującym typem pakietu:
</p>

<div class="c">
<pre>#define GG_SEND_MSG80 0x002d

struct gg_send_msg80 {
	int recipient;		<i>/* numer odbiorcy */</i>
	int seq;		<i>/* numer sekwencyjny */</i>
	int class;		<i>/* klasa wiadomości */</i>
	int offset_plain;	<i>/* położenie treści czystym tekstem */</i>
	int offset_attributes;	<i>/* położenie atrybutów */</i>
	char html_message[];	<i>/* treść w formacie HTML (zakończona \0) */</i>
	char plain_message[];	<i>/* treść czystym tekstem (zakończona \0) */</i>
	char attributes[];	<i>/* atrybuty wiadomości */</i>
};</pre>

</div>

<p>
Numer sekwencyjny w poprzednich wersjach protokołu był losową liczbą
pozwalającą przypisać potwierdzenie do wiadomości. Obecnie jest znacznikiem
czasu w postaci uniksowej (liczba sekund od 1 stycznia 1970r. UTC).
</p>

<p>
Klasa wiadomości jest mapą bitową (domyślna wartość to <tt>0x08</tt>):
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Etykieta</b></td><td><b>Wartość</b></td><td><b>Znaczenie</b></td></tr>
<tr class="tabf"><td><tt>GG_CLASS_QUEUED</tt></td><td><tt>0x0001</tt></td><td>Bit ustawiany wyłącznie przy odbiorze wiadomości, gdy wiadomość została wcześniej zakolejkowania z powodu nieobecności</td></tr>
<tr class="tabf"><td><tt>GG_CLASS_MSG</tt></td><td><tt>0x0004</tt></td><td>Wiadomość ma się pojawić w osobnym okienku (nieużywane)</td></tr>
<tr class="tabf"><td><tt>GG_CLASS_CHAT</tt></td><td><tt>0x0008</tt></td><td>Wiadomość jest częścią toczącej się rozmowy i zostanie wyświetlona w istniejącym okienku</td></tr>
<tr class="tabf"><td><tt>GG_CLASS_CTCP</tt></td><td><tt>0x0010</tt></td><td>Wiadomość jest przeznaczona dla klienta Gadu-Gadu i nie powinna być wyświetlona użytkownikowi (nieużywane)</td></tr>
<tr class="tabf"><td><tt>GG_CLASS_ACK</tt></td><td><tt>0x0020</tt></td><td>Klient nie życzy sobie potwierdzenia wiadomości</td></tr>
</table>

<p>
Długość treści wiadomości nie powinna przekraczać 2000 znaków. Oryginalny
klient zezwala na wysłanie do 1989 znaków. Treść w formacie HTML jest kodowana
UTF-8. Treść zapisana czystym tekstem jest kodowana zestawem znaków CP1250.
W obu przypadkach, mimo domyślnych atrybutów tekstu, oryginalny klient dodaje
informacje o formatowaniu tekstu. Dla HTML wygląda to następująco:
</p>

<div class="http">
<pre>&lt;span style="color:#000000; font-family:'MS Shell Dlg 2'; font-size:9pt; "&gt;Treść&lt;/span&gt;</pre>
</div>

<p>
Dla czystego tekstu dodawane są informacje o tym, że tekst ma kolor czarny:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Bajty</b></td><td><b>Opis</b></td></tr>
<tr class="tabf"><td><tt>0x02</tt></td><td>Flaga formatowania tekstu</td></tr>
<tr class="tabf"><td><tt>0x06 0x00</tt></td><td>Długość bloku formatowania wynosi 6 bajtów</td></tr>
<tr class="tabf"><td><tt>0x00 0x00</tt></td><td>Atrybut tekstu od pozycji 0</td></tr>
<tr class="tabf"><td><tt>0x08</tt></td><td>Tekst kolorowy</td></tr>
<tr class="tabf"><td><tt>0x00 0x00 0x00</tt></td><td>Kolor czarny</td></tr>
</table>

<a name="ch1.6.1"></a>
<h4>1.6.1. Konferencje</h4>

<p>
Podczas konferencji ta sama wiadomość jest wysyłana do wszystkich odbiorców,
a do sekcji atrybutów dołączana jest lista pozostałych uczestników konferencji.
Dla przykładu, jeśli w konferencji biorą udział Ala, Bartek, Celina i Darek,
to osoba Ala wysyła wysyła do Bartka wiadomość z listą zawierającą numery
Celiny i Darka, do Celiny z numerami Bartka i Darka, a do Darka z numerami
Bartka i Celiny. Lista pozostałych uczestników konferencji jest przekazywana
za pomocą struktury:
</p>

<div class="c">
<pre>struct gg_msg_recipients {
	char flag;		<i>/* 0x01 */</i>
	int count;		<i>/* liczba odbiorców */</i>
	int recipients[];	<i>/* lista odbiorców */</i>
};</pre>
</div>

<p>
Na przykład, by wysłać wysłać do do dwóch osób, należy wysłać pakiet z
wiadomością o treści:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Bajty</b></td><td><b>Opis</b></td></tr>
<tr class="tabf"><td><tt>0x01</tt></td><td>Flaga wiadomości konferencyjnej</td></tr>
<tr class="tabf"><td><tt>0x02 0x00 0x00 0x00</tt></td><td>Liczba pozostałych uczestników</td></tr>
<tr class="tabf"><td><tt>0xXX 0xXX 0xXX 0xXX</tt></td><td>Numer uczestnika #2</td></tr>
<tr class="tabf"><td><tt>0xYY 0xYY 0xYY 0xYY</tt></td><td>Numer uczestnika #3</td></tr>
</table>

<a name="ch1.6.2"></a>
<h4>1.6.2. Formatowanie tekstu</h4>

<p>
Możliwe jest również dodawanie do wiadomości różnych atrybutów tekstu, jak
pogrubienie czy kolory. Niezbędne jest dołączenie następującej struktury:
</p>

<div class="c">
<pre>struct gg_msg_richtext {
	char flag;	<i>/* 0x02 */</i>
	short length;	<i>/* długość dalszej części */</i>
};</pre>
</div>

<p>
Dalsza część pakietu zawiera odpowiednią ilość struktur o łącznej długości
określonej polem <tt>length</tt>:
</p>

<div class="c">
<pre>struct gg_msg_richtext_format {
	short position;	<i>/* pozycja atrybutu w tekście */</i>
	char font;	<i>/* atrybuty czcionki */</i>
	char rgb[3];	<i>/* kolor czcionki (nie musi wystąpić) */</i>
	struct gg_msg_richtext_image image; <i>/* obrazek (nie musi wystąpić) */</i>
};</pre>
</div>

<p>
Każda z tych struktur określa kawałek tekstu począwszy od znaku określonego
przez pole <tt>position</tt> (liczone od zera) aż do następnego wpisu lub
końca tekstu. Pole <tt>font</tt> jest mapą bitową i kolejne bity mają
następujące znaczenie:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Etykieta</b></td><td><b>Wartość</b></td><td><b>Znaczenie</b></td></tr>
<tr class="tabf"><td><tt>GG_FONT_BOLD</tt></td><td><tt>0x01</tt></td><td>Pogrubiony tekst</td></tr>
<tr class="tabf"><td><tt>GG_FONT_ITALIC</tt></td><td><tt>0x02</tt></td><td>Kursywa</td></tr>
<tr class="tabf"><td><tt>GG_FONT_UNDERLINE</tt></td><td><tt>0x04</tt></td><td>Podkreślenie</td></tr>
<tr class="tabf"><td><tt>GG_FONT_COLOR</tt></td><td><tt>0x08</tt></td><td>Kolorowy tekst. Tylko w tym wypadku struktura <tt>gg_msg_richtext_format</tt> zawiera pole <tt>rgb[]</tt> będące opisem trzech składowych koloru, kolejno czerwonej, zielonej i niebieskiej.</td></tr>
<tr class="tabf"><td><tt>GG_FONT_IMAGE</tt></td><td><tt>0x80</tt></td><td>Obrazek. Tylko w tym wypadku struktura <tt>gg_msg_richtext_format</tt> zawiera pole <tt>image</tt>.</td></tr>
</table>

<p>
Jeśli wiadomość zawiera obrazek, przesyłana jest jego suma kontrolna CRC32
i rozmiar. Dzięki temu nie trzeba za każdym razem wysyłać każdego obrazka
&mdash; klienty je zachowują. Struktura <tt>gg_msg_richtext_image</tt> opisująca
obrazek umieszczony w wiadomości wygląda następująco:
</p>

<div class="c">
<pre>struct gg_msg_richtext_image {
	short unknown1;	<i>/* 0x0109 */</i>
	int size;	<i>/* rozmiar obrazka */</i>
	int crc32;	<i>/* suma kontrolna obrazka */</i>
};</pre>
</div>

<p>
Przykładowo, by przesłać tekst &bdquo;ala <b>ma</b> kota&rdquo;, należy
dołączyć do wiadomości następującą sekwencję bajtów:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Bajty</b></td><td><b>Opis</b></td></tr>
<tr class="tabf"><td><tt>0x02</tt></td><td>Flaga formatowania tekstu</td></tr>
<tr class="tabf"><td><tt>0x06 0x00</tt></td><td>Długość bloku formatowania wynosi 6 bajtów</td></tr>
<tr class="tabf"><td><tt>0x04 0x00</tt></td><td>Atrybut tekstu od pozycji 4</td></tr>
<tr class="tabf"><td><tt>0x01</tt></td><td>Tekst pogrubiony</td></tr>
<tr class="tabf"><td><tt>0x06 0x00</tt></td><td>Atrybut tekstu od pozycji 6</td></tr>
<tr class="tabf"><td><tt>0x00</tt></td><td>Tekst normalny</td></tr>
</table>

<p>
W przypadku gdy wiadomość zawiera zarówno informacje o uczestnikach konferencji,
jaki i o formatowaniu, najpierw informacje o konferencji powinny znajdować się
przed formatowaniem.
</p>

<p>
Jeśli obrazek jest przesyłany w wiadomości bez tekstu, jej treść powinna
zawierać znak niełamliwej spacji (kod 160 w kodowaniu CP1250). W innym
przypadku nowsze klienty (np. Nowe Gadu-Gadu) nie wyświetlą obrazka.
</p>

<a name="ch1.6.3"></a>
<h4>1.6.3. Przesyłanie obrazków</h4>

<p>
Gdy klient nie posiada w pamięci podręcznej obrazka o podanych parametrach,
wysyła pustą wiadomość o klasie <tt>GG_CLASS_MSG</tt> z dołączoną strukturą
<tt>gg_msg_image_request</tt>:
</p>

<div class="c">
<pre>struct gg_msg_image_request {
	char flag;	<i>/* 0x04 */</i>
	int size;	<i>/* rozmiar */</i>
	int crc32;	<i>/* suma kontrolna */</i>
};</pre>
</div>

<p>
Przykładowa treść wiadomości z prośbą o wysłanie obrazka o długości 10000
bajtów i sumie kontrolnej 0x12345678 to:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Bajty</b></td><td><b>Opis</b></td></tr>
<tr class="tabf"><td><tt>0x04</tt></td><td>Flaga pobrania obrazka</td></tr>
<tr class="tabf"><td><tt>0x10 0x27 0x00 0x00</tt></td><td>Rozmiar obrazka w bajtach</td></tr>
<tr class="tabf"><td><tt>0x78 0x56 0x34 0x12</tt></td><td>Suma kontrolna</td></tr>
</table>

<p>
W odpowiedzi, drugi klient wysyła obrazek za pomocą wiadomości o zerowej
długości (należy pamiętać o kończącym bajcie o wartości <tt>0x00</tt>)
z dołączoną strukturą <tt>gg_msg_image_reply</tt>:
</p>

<div class="c">
<pre>struct gg_msg_image_reply {
	char flag;      	<i>/* 0x05 lub 0x06 */</i>
	int size;       	<i>/* rozmiar */</i>
	int crc32;      	<i>/* suma kontrolna */</i>
	char filename[];	<i>/* nazwa pliku (nie musi wystąpić) */</i>
	char image[];		<i>/* zawartość obrazka (nie musi wystąpić) */</i>
};</pre>
</div>

<p>
Jeśli długość struktury <tt>gg_msg_image_reply</tt> jest dłuższa niż 1909
bajtów, treść obrazka jest dzielona na kilka pakietów nie przekraczających
1909 bajtów. Pierwszy pakiet ma pole <tt>flag</tt> równe <tt>0x05</tt> i ma
wypełnione pole <tt>filename</tt>, a w kolejnych pole <tt>flag</tt> jest równe
<tt>0x06</tt> i pole <tt>filename</tt> w ogóle nie występuje (nawet bajt
zakończenia ciągu znaków).
</p>

<p>
Jeśli otrzymamy pakiet bez pola <tt>filename</tt> oraz <tt>image</tt>, oznacza
to, że klient nie posiada żądanego obrazka.
</p>

<a name="ch1.6.4"></a>
<h4>1.6.4. Potwierdzenie</h4>

<p>
Serwer po otrzymaniu wiadomości odsyła potwierdzenie, które przy okazji
mówi nam, czy wiadomość dotarła do odbiorcy czy została zakolejkowana
z powodu nieobecności. Otrzymujemy je w postaci pakietu:
</p>

<div class="c">
<pre>#define GG_SEND_MSG_ACK 0x0005
	
struct gg_send_msg_ack {
	int status;	<i>/* stan wiadomości */</i>
	int recipient;	<i>/* numer odbiorcy */</i>
	int seq;	<i>/* numer sekwencyjny */</i>
};</pre>
</div>

<p>
Numer sekwencyjny i numer adresata są takie same jak podczas wysyłania,
a stan wiadomości może być jednym z następujących:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Etykieta</b></td><td><b>Wartość</b></td><td><b>Znaczenie</b></td></tr>
<tr class="tabf"><td><tt>GG_ACK_BLOCKED</tt></td><td><tt>0x0001</tt></td><td>Wiadomości nie przesłano (zdarza się przy wiadomościach zawierających adresy internetowe blokowanych przez serwer GG gdy odbiorca nie ma nas na liście)</td></tr>
<tr class="tabf"><td><tt>GG_ACK_DELIVERED</tt></td><td><tt>0x0002</tt></td><td>Wiadomość dostarczono</td></tr>
<tr class="tabf"><td><tt>GG_ACK_QUEUED</tt></td><td><tt>0x0003</tt></td><td>Wiadomość zakolejkowano</td></tr>
<tr class="tabf"><td><tt>GG_ACK_MBOXFULL</tt></td><td><tt>0x0004</tt></td><td>Wiadomości nie dostarczono. Skrzynka odbiorcza na serwerze jest pełna (20 wiadomości maks). Występuje tylko w trybie offline</td></tr>
<tr class="tabf"><td><tt>GG_ACK_NOT_DELIVERED</tt></td><td><tt>0x0006</tt></td><td>Wiadomości nie dostarczono. Odpowiedź ta występuje tylko w przypadku wiadomości klasy <tt>GG_CLASS_CTCP</tt></td></tr>
</table>

<hr />

<a name="ch1.7"></a>
<h3>1.7. Otrzymywanie wiadomości</h3>

<p>
Wiadomości serwer przysyła za pomocą pakietu:
</p>

<div class="c">
<pre>#define GG_RECV_MSG80 0x002e

struct gg_recv_msg80 {
	int sender;		<i>/* numer nadawcy */</i>
	int seq;		<i>/* numer sekwencyjny */</i>
	int time;		<i>/* czas nadania */</i>
	int class;		<i>/* klasa wiadomości */</i>
	int offset_plain;	<i>/* położenie treści czystym tekstem */</i>
	int offset_attributes;	<i>/* położenie atrybutów */</i>
	char html_message[];	<i>/* treść w formacie HTML (zakończona \0) */</i>
	char plain_message[];	<i>/* treść czystym tekstem (zakończona \0) */</i>
	char attributes[];	<i>/* atrybuty wiadomości */</i>
};</pre>

</div>

<p>
Czas nadania jest zapisany w postaci UTC, jako ilości sekund od 1 stycznia
1970r.
</p>

<p>
W przypadku pakietów &bdquo;konferencyjnych&rdquo; na końcu pakietu doklejona
jest struktura identyczna z <tt>gg_msg_recipients</tt> zawierająca pozostałych
rozmówców.
</p>

<hr />

<a name="ch1.8"></a>
<h3>1.8. Ping, pong</h3>

<p>
Od czasu do czasu klient wysyła pakiet do serwera, by oznajmić, że połączenie
jeszcze jest utrzymywane. Jeśli serwer nie dostanie takiego pakietu w
przeciągu 5 minut, zrywa połączenie. To, czy klient dostaje odpowiedź
zmienia się z wersji na wersję, więc najlepiej nie polegać na tym.
</p>

<div class="c">
<pre>#define GG_PING 0x0008

#define GG_PONG 0x0007</pre>
</div>

<hr />

<a name="ch1.9"></a>
<h3>1.9. Rozłączenie</h3>

<p>
Jeśli serwer zechce nas rozłączyć, wyśle wcześniej pusty pakiet:
</p>

<div class="c">
<pre>#define GG_DISCONNECTING 0x000b</pre>
</div>

<p>
Ma to miejsce, gdy próbowano zbyt wiele razy połączyć się z nieprawidłowym
hasłem (wtedy pakiet zostanie wysłany w odpowiedzi na GG_LOGIN70), lub gdy 
równocześnie połączy się drugi klient z tym samym numerem (nowe połączenie 
ma wyższy priorytet).
</p>

<p>
W nowych wersjach protokołu (prawdopodobnie od <tt>0x29</tt>), po wysłaniu
pakietu zmieniającego status na niedostępny, serwer przysyła pakiet:
</p>

<div class="c">
<pre>#define GG_DISCONNECT_ACK 0x000d</pre>
</div>

<p>
Jest to potwierdzenie, że serwer odebrał pakiet zmiany stanu i klient może
zakończyć połączenie mając pewność, że zostanie ustawiony żądany opis.
</p>

<hr />

<a name="ch1.10"></a>
<h3>1.10. Wiadomości systemowe</h3>

<p>
Od wersji 7.7 serwer może wysyłać nam wiadomości systemowe przy pomocy pakietu:
</p>

<div class="c">
<pre>#define GG_XML_EVENT 0x0027</pre>
</div>

<p>
Wiadomość systemowa zawiera kod XML zakodowany w UTF-8 z informacjami dotyczącymi 
np. przedłużenia konta w mobilnym GG, czy nowej wiadomości na poczcie głosowej. 
Przykładowy kod:
</p>

<div class="example">
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;event xmlns:ev="www.gadu-gadu.pl/Event/1.0" id ="" type="realtime" creation_time="1194732873" ttl="60"&gt;
&lt;ev:actions&gt;
&lt;ev:showMessage&gt;
&lt;ev:text&gt;Wejdź na stronę EKG&lt;/ev:text&gt;

&lt;ev:executeHtml url="ekg.chmurka.net" /&gt;
&lt;/ev:showMessage&gt;
&lt;/ev:actions&gt;
&lt;/event&gt;</pre>
</div>

<hr />

<a name="ch1.11"></a>
<h3>1.11. Wiadomości GGLive</h3>
<div class="check">
<p>Opisać usługi http://life.gadu-gadu.pl/<br/>
Logowanie OAuth: /login?oauth_consumer_key=UIN&amp;oauth_nonce=....&amp;oauth_signature=...&amp;oauth_signature_method=HMAC-SHA1&amp;oauth_timestamp=...&amp;oauth_token=....&amp;oauth_version=1.0<br/>
Wysyłanie: POST /send/message/?USER_IS_AUTHENTICATED=1&amp;uin=UIN&amp;token=TOKEN<br/>
message=Testowa+wiadomo%C5%9B%C4%87&amp;send=Wy%C5%9Blij<br/>
</p>
</div>

<div class="c">
<pre>#define GG_XML_ACTION 0x002c</pre>
</div>

<p>
Przykładowa otrzymana wiadomość:
</p>
<div class="example">
<pre>
&lt;events&gt;
  &lt;event id="13106118792229117994"&gt;
  &lt;type&gt;1&lt;/type&gt;
  &lt;sender&gt;7496195&lt;/sender&gt;
  &lt;time&gt;1243461221&lt;/time&gt;
  &lt;bodyXML&gt;
     &lt;serviceID&gt;lifestreaming&lt;/serviceID&gt;
     &lt;msg&gt;&lt;![CDATA[Testowa wiadomość]]&gt;&lt;/msg&gt;
     &lt;link isLogin="0"&gt;&lt;/link&gt;
     &lt;creationTime&gt;1243461221&lt;/creationTime&gt;
  &lt;/bodyXML&gt;
 &lt;/event&gt;
&lt;/events&gt;
</pre>
</div>

<hr />

<a name="ch1.12"></a>
<h3>1.12. Katalog publiczny</h3>

<div class="check">
<p>Nowe Gadu-Gadu korzysta z OAutha do odczytu oraz zmian danych w katalogu, API opisane jest na:
<a href="http://dev.gadu-gadu.pl/api/pages/gaduapi.html">http://dev.gadu-gadu.pl/api/pages/gaduapi.html</a>
</p>
<p>Nowe Gadu-Gadu korzysta z wyszukiwarki dostępnej na:
<a href="http://ipubdir.gadu-gadu.pl">http://ipubdir.gadu-gadu.pl</a>
</p>
</div>

<p>
Od wersji 5.0.2 zmieniono sposób dostępu do katalogu publicznego &mdash; stał
się częścią sesji, zamiast osobnej sesji HTTP. Aby obsługiwać wyszukiwanie
osób, odczytywanie własnych informacji lub ich modyfikację należy użyć
następującego typu pakietu:
</p>

<div class="c">
<pre>#define GG_PUBDIR50_REQUEST 0x0014
	
struct gg_pubdir50 {
	char type;
	int seq;
	char request[];
};</pre>
</div>

<p>
Pole <tt>type</tt> oznacza rodzaj zapytania:
</p>

<div class="c">
<pre>#define GG_PUBDIR50_WRITE 0x01
#define GG_PUBDIR50_READ 0x02
#define GG_PUBDIR50_SEARCH 0x03</pre>
</div>

<p>
Pole <tt>seq</tt> jest numerem sekwencyjnym zapytania, różnym od zera,
zwracanym również
w wyniku. Oryginalny klient tworzy go na podstawie aktualnego czasu.
<tt>request</tt> zawiera parametry zapytania. Ilość jest dowolna. Każdy
parametr jest postaci <tt>"<b>nazwa</b>\0<b>wartość</b>\0"</tt>, tzn.
nazwa od wartości są oddzielone znakiem o kodzie 0, podobnie jak kolejne
parametry od siebie. Możliwe parametry zapytania to:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Etykieta</b></td><td><b>Wartość</b></td><td><b>Znaczenie</b></td></tr>
<tr class="tabf"><td><tt>GG_PUBDIR50_UIN</tt></td><td><tt>FmNumber</tt></td><td>Numer szukanej osoby</td></tr>
<tr class="tabf"><td><tt>GG_PUBDIR50_FIRSTNAME</tt></td><td><tt>firstname</tt></td><td>Imię</td></tr>
<tr class="tabf"><td><tt>GG_PUBDIR50_LASTNAME</tt></td><td><tt>lastname</tt></td><td>Nazwisko</td></tr>
<tr class="tabf"><td><tt>GG_PUBDIR50_NICKNAME</tt></td><td><tt>nickname</tt></td><td>Pseudonim</td></tr>
<tr class="tabf"><td><tt>GG_PUBDIR50_BIRTHYEAR</tt></td><td><tt>birthyear</tt></td><td>Rok urodzenia. Jeśli chcemy szukać osób z danego przedziału, podajemy rok początkowy i końcowy, oddzielone spacją. Na przykład &bdquo;<tt>1980 1985</tt>&rdquo;.</td></tr>
<tr class="tabf"><td><tt>GG_PUBDIR50_CITY</tt></td><td><tt>city</tt></td><td>Miejscowość</td></tr>
<tr class="tabf"><td><tt>GG_PUBDIR50_GENDER</tt></td><td><tt>gender</tt></td><td>Płeć. Jeśli szukamy kobiet, ma wartość &bdquo;<tt>1</tt>&rdquo; (stała <tt>GG_PUBDIR50_GENDER_FEMALE</tt>). Jeśli mężczyzn, ma wartość &bdquo;<tt>2</tt>&rdquo; (stała <tt>GG_PUBDIR50_GENDER_MALE</tt>). W przypadku pobierania lub ustawiania informacji o sobie stałe mają odwrócone znaczenia (stałe <tt>GG_PUBDIR50_GENDER_SET_FEMALE</tt> i <tt>GG_PUBDIR50_GENDER_SET_MALE</tt>)</td></tr>
<tr class="tabf"><td><tt>GG_PUBDIR50_ACTIVE</tt></td><td><tt>ActiveOnly</tt></td><td>Jeśli szukamy tylko dostępnych osób, ma mieć wartość &bdquo;<tt>1</tt>&rdquo; (stała <tt>GG_PUBDIR50_ACTIVE_TRUE</tt>).</td></tr>
<tr class="tabf"><td><tt>GG_PUBDIR50_FAMILYNAME</tt></td><td><tt>familyname</tt></td><td>Nazwisko panieńskie. Ma znaczenie tylko przy ustawianiu własnych danych.</td></tr>
<tr class="tabf"><td><tt>GG_PUBDIR50_FAMILYCITY</tt></td><td><tt>familycity</tt></td><td>Miejscowość pochodzenia. Ma znaczenie tylko przy ustawianiu własnych danych.</td></tr>
<tr class="tabf"><td><tt>GG_PUBDIR50_START</tt></td><td><tt>fmstart</tt></td><td>Numer, od którego rozpocząć wyszukiwanie. Ma znaczenie, gdy kontynuujemy wyszukiwanie.</td></tr>
</table>

<p>
Treść przykładowego zapytania (pomijając pola <tt>type</tt> i <tt>seq</tt>) znajduje się poniżej. Szukano dostępnych kobiet o imieniu Ewa z Warszawy. Znaki o kodzie 0 zastąpiono kropkami.
</p>

<div class="example">
<pre>firstname.Ewa.city.Warszawa.gender.1.ActiveOnly.1.</pre>
</div>

<p>
Wynik zapytania zostanie zwrócony za pomocą pakietu:
</p>

<div class="c">
<pre>#define GG_PUBDIR50_REPLY 0x000e
	
struct gg_pubdir50_reply {
	char type;
	int seq;
	char reply[];
};</pre>
</div>

<p>
Pole <tt>type</tt> poza wartościami takimi jak przy pakiecie typu
<tt>GG_PUBDIR50_REQUEST</tt> może przyjąć jeszcze wartość oznaczającą
odpowiedź wyszukiwania:
</p>

<div class="c">
<pre>#define GG_PUBDIR50_SEARCH_REPLY 0x05</pre>
</div>

<p>
Wyniki są zbudowane identycznie jak w przypadku zapytań, z tą różnicą, że
kolejne osoby oddzielane pustym polem: <tt>"<b>parametr</b>\0<b>wartość</b>\0\0<b>parametr</b>\0<b>wartość</b>\0"</tt>.
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Etykieta</b></td><td><b>Wartość</b></td><td><b>Znaczenie</b></td></tr>
<tr class="tabf"><td><tt>GG_PUBDIR50_STATUS</tt></td><td><tt>FmStatus</tt></td><td>Stan szukanej osoby</td></tr>
<tr class="tabf"><td>&nbsp;</td><td><tt>nextstart</tt></td><td>Pole występujące w ostatnim wyniku, określające, od jakiego numeru należy rozpocząć wyszukiwanie, by otrzymać kolejną porcję danych. Podaje się go w zapytaniu jako parametr &bdquo;<tt>start</tt>&rdquo;.</td></tr>
</table>

<p>
Przykładowy wynik zawierający dwie znalezione osoby:
</p>

<div class="example">
<pre>FmNumber.12345.FmStatus.1.firstname.Adam.nickname.Janek.birthyear.1979.city.Wzdów
..FmNumber.3141592.FmStatus.5.firstname.Ewa.nickname.Ewcia.birthyear.1982.city.Gd
dańsk..nextstart.0.</pre>
</div>

<p>
Wyszukiwanie <b>nie zwraca</b> nazwisk i płci znalezionych osób.
</p>

<hr />

<a name="ch1.13"></a>
<h3>1.13. Lista kontaktów</h3>

<div class="check">
<pre>Sprawdzić czy wszystkie #define dalej są potrzebne</pre>
</div>

<p>
Od wersji 6.0 lista kontaktów na serwerze stała częścią sesji, zamiast
osobnej sesji HTTP. Aby wysłać lub pobrać listę kontaktów z serwera należy
użyć pakietu:
</p>

<div class="c">
<pre>#define GG_USERLIST_REQUEST80 0x002f
	
struct gg_userlist_request {
	char type;		<i>/* rodzaj zapytania */</i>
	char request[];		<i>/* treść (nie musi wystąpić) */</i>
};</pre>
</div>

<p>
Pole <tt>type</tt> oznacza rodzaj zapytania:
</p>

<div class="c">
<pre>#define GG_USERLIST_PUT 0x00            <i>/* początek eksportu listy */</i>
#define GG_USERLIST_PUT_MORE 0x01       <i>/* dalsza część eksportu listy */</i>
#define GG_USERLIST_GET 0x02            <i>/* import listy */</i></pre>
</div>

<p>
W przypadku eksportu listy kontaktów, pole <tt>request</tt> zawiera dokument
XML opisany na stronie
<a href="http://dev.gadu-gadu.pl/api/pages/formaty_plikow.html">http://dev.gadu-gadu.pl/api/pages/formaty_plikow.html</a> skompresowany algorytmem 
<a href="http://pl.wikipedia.org/wiki/Deflate">Deflate</a>. Wolnodostępna
implementacja algorytmu, używana również przez oryginalnego klienta, znajduje
się w biblotece <a href="http://www.zlib.net/">zlib</a>. 
</p>

<p>
Podczas przesyłania lista kontaktów jest dzielona na pakiety po 2048 bajtów.
Pierwszy jest wysyłany pakietem typu <tt>GG_USERLIST_PUT</tt>, żeby uaktualnić
plik na serwerze, pozostałe typu <tt>GG_USERLIST_PUT_MORE</tt>, żeby dopisać
do pliku.
</p>

<p>
Na zapytania dotyczące listy kontaktów serwer odpowiada pakietem:
</p>

<div class="c">
<pre>#define GG_USERLIST_REPLY80 0x0030
	
struct gg_userlist_reply {
	char type;		<i>/* rodzaj zapytania */</i>
	char reply[];		<i>/* treść (nie musi wystąpić) */</i>
};</pre>
</div>

<p>
Pole <tt>type</tt> oznacza rodzaj odpowiedzi:
</p>

<div class="c">
<pre>#define GG_USERLIST_PUT_REPLY 0x00         <i>/* początek eksportu listy */</i>
#define GG_USERLIST_PUT_MORE_REPLY 0x02    <i>/* kontynuacja */</i>
#define GG_USERLIST_GET_MORE_REPLY 0x04    <i>/* początek importu listy */</i>
#define GG_USERLIST_GET_REPLY 0x06         <i>/* ostatnia część importu */</i></pre>
</div>

<p>
W przypadku importu w polu <tt>request</tt> znajdzie się lista kontaktów
w takiej samej postaci, w jakiej ją umieszczono. Serwer nie ingeruje w jej
treść. Podobnie jak przy wysyłaniu, przychodzi podzielona na mniejsze pakiety.
Pobieranie krótkiej listy kontaktów zwykle powoduje wysłanie pojedynczego
pakietu <tt>GG_USERLIST_GET_REPLY</tt>, a gdy lista jest długa, serwer może
przysłać dowolną ilość pakietów <tt>GG_USERLIST_GET_MORE_REPLY</tt> przed
pakietem <tt>GG_USERLIST_GET_REPLY</tt>.
</p>

<p>
Aby usunąć listę kontaktów z serwera oryginalny klient wysyła spację jako
listę kontaktów czego wynikiem jest pole <tt>request</tt> o zawartości:
</p>

<div class="example">
<pre>78 da 53 00 00 00 21 00 21</pre>
</div>

<hr />

<a name="ch1.14"></a>
<h3>1.14. Indeks pakietów</h3>

<p>
Pakiety wysyłane:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Wartość</b></td><td><b>Etykieta</b></td><td><b>Znaczenie</b></td></tr>
<tr class="tabf2"><td><tt>0x0002</tt></td><td><tt>GG_NEW_STATUS</tt></td><td>Zmiana stanu przed GG 8.0</td></tr>
<tr class="tabf2"><td><tt>0x0007</tt></td><td><tt>GG_PONG</tt></td><td>Pong</td></tr>
<tr class="tabf"><td><tt>0x0008</tt></td><td><tt>GG_PING</tt></td><td>Ping</td></tr>
<tr class="tabf2"><td><tt>0x000b</tt></td><td><tt>GG_SEND_MSG</tt></td><td>Wysłanie wiadomości przed GG 8.0</td></tr>
<tr class="tabf2"><td><tt>0x000c</tt></td><td><tt>GG_LOGIN</tt></td><td>Logowanie przed GG 6.0</td></tr>
<tr class="tabf"><td><tt>0x000d</tt></td><td><tt>GG_ADD_NOTIFY</tt></td><td>Dodanie do listy kontaktów</td></tr>
<tr class="tabf"><td><tt>0x000e</tt></td><td><tt>GG_REMOVE_NOTIFY</tt></td><td>Usunięcie z listy kontaktów</td></tr>
<tr class="tabf"><td><tt>0x000f</tt></td><td><tt>GG_NOTIFY_FIRST</tt></td><td>Początkowy fragment listy kontaktów większej niż 400 wpisów</td></tr>
<tr class="tabf"><td><tt>0x0010</tt></td><td><tt>GG_NOTIFY_LAST</tt></td><td>Ostatni fragment listy kontaktów</td></tr>
<tr class="tabf"><td><tt>0x0012</tt></td><td><tt>GG_LIST_EMPTY</tt></td><td>Lista kontaktów jest pusta</td></tr>
<tr class="tabf2"><td><tt>0x0013</tt></td><td><tt>GG_LOGIN_EXT</tt></td><td>Logowanie przed GG 6.0</td></tr>
<tr class="tabf"><td><tt>0x0014</tt></td><td><tt>GG_PUBDIR50_REQUEST</tt></td><td>Zapytanie katalogu publicznego</td></tr>
<tr class="tabf2"><td><tt>0x0015</tt></td><td><tt>GG_LOGIN60</tt></td><td>Logowanie przed GG 7.7</td></tr>
<tr class="tabf2"><td><tt>0x0016</tt></td><td><tt>GG_USERLIST_REQUEST</tt></td><td>Zapytanie listy kontaktów na serwerze przed Nowym Gadu-Gadu</td></tr>
<tr class="tabf2"><td><tt>0x0019</tt></td><td><tt>GG_LOGIN70</tt></td><td>Logowanie przed GG 8.0</td></tr>
<tr class="tabf"><td><tt>0x001f</tt></td><td><tt>GG_DCC7_INFO</tt></td><td></td></tr>
<tr class="tabf"><td><tt>0x0020</tt></td><td><tt>GG_DCC7_NEW</tt></td><td>Informacje o chęci nawiązania połączenia DCC</td></tr>
<tr class="tabf"><td><tt>0x0021</tt></td><td><tt>GG_DCC7_ACCEPT</tt></td><td>Zaakceptowanie połączenia DCC</td></tr>
<tr class="tabf"><td><tt>0x0022</tt></td><td><tt>GG_DCC7_REJECT</tt></td><td>Odrzucenie połączenia DCC</td></tr>
<tr class="tabf"><td><tt>0x0023</tt></td><td><tt>GG_DCC7_ID_REQUEST</tt></td><td></td></tr>
<tr class="tabf2"><td><tt>0x0024</tt></td><td><tt>GG_DCC7_DUNNO1</tt></td><td></td></tr>
<tr class="tabf"><td><tt>0x0025</tt></td><td><tt>GG_DCC7_ABORT</tt></td><td></td></tr>
<tr class="tabf2"><td><tt>0x0028</tt></td><td><tt>GG_NEW_STATUS80BETA</tt></td><td>Zmiana stanu przed Nowym Gadu-Gadu</td></tr>
<tr class="tabf2"><td><tt>0x0029</tt></td><td><tt>GG_LOGIN80BETA</tt></td><td>Logowanie przed Nowym Gadu-Gadu</td></tr>
<tr class="tabf"><td><tt>0x002d</tt></td><td><tt>GG_SEND_MSG80</tt></td><td>Wysłanie wiadomości</td></tr>
<tr class="tabf"><td><tt>0x002f</tt></td><td><tt>GG_USERLIST_REQUEST80</tt></td><td>Zapytanie listy kontaktów na serwerze</td></tr>
<tr class="tabf"><td><tt>0x0031</tt></td><td><tt>GG_LOGIN80</tt></td><td>Logowanie</td></tr>
<tr class="tabf"><td><tt>0x0038</tt></td><td><tt>GG_NEW_STATUS80</tt></td><td>Zmiana stanu</td></tr>
</table>

<p>
Pakiety odbierane:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Wartość</b></td><td><b>Etykieta</b></td><td><b>Znaczenie</b></td></tr>
<tr class="tabf"><td><tt>0x0001</tt></td><td><tt>GG_WELCOME</tt></td><td>Liczba do wyznaczenie hashu hasła</td></tr>
<tr class="tabf2"><td><tt>0x0002</tt></td><td><tt>GG_STATUS</tt></td><td>Zmiana stanu przed GG 6.0</td></tr>
<tr class="tabf2"><td><tt>0x0003</tt></td><td><tt>GG_LOGIN_OK</tt></td><td>Logowanie powiodło się przed Nowym Gadu-Gadu</td></tr>
<tr class="tabf"><td><tt>0x0005</tt></td><td><tt>GG_SEND_MSG_ACK</tt></td><td>Potwierdzenie wiadomości</td></tr>
<tr class="tabf2"><td><tt>0x0007</tt></td><td><tt>GG_PONG</tt></td><td>Pong</td></tr>
<tr class="tabf2"><td><tt>0x0008</tt></td><td><tt>GG_PING</tt></td><td>Ping</td></tr>
<tr class="tabf"><td><tt>0x0009</tt></td><td><tt>GG_LOGIN_FAILED</tt></td><td>Logowanie nie powiodło się</td></tr>
<tr class="tabf2"><td><tt>0x000a</tt></td><td><tt>GG_RECV_MSG</tt></td><td>Przychodząca wiadomość przed GG 8.0</td></tr>
<tr class="tabf"><td><tt>0x000b</tt></td><td><tt>GG_DISCONNECTING</tt></td><td>Zerwanie połączenia</td></tr>
<tr class="tabf2"><td><tt>0x000c</tt></td><td><tt>GG_NOTIFY_REPLY</tt></td><td>Stan listy kontaktów przed GG 6.0</td></tr>
<tr class="tabf"><td><tt>0x000d</tt></td><td><tt>GG_DISCONNECT_ACK</tt></td><td>Zerwanie połączenia po zmianie stanu na niedostępny</td></tr>
<tr class="tabf"><td><tt>0x000e</tt></td><td><tt>GG_PUBDIR50_REPLY</tt></td><td>Odpowiedź katalogu publicznego</td></tr>
<tr class="tabf2"><td><tt>0x000f</tt></td><td><tt>GG_STATUS60</tt></td><td>Zmiana stanu przed GG 7.7</td></tr>
<tr class="tabf2"><td><tt>0x0010</tt></td><td><tt>GG_USERLIST_REPLY</tt></td><td>Odpowiedź listy kontaktów na serwerze przed nowym Gadu-Gadu</td></tr>
<tr class="tabf2"><td><tt>0x0011</tt></td><td><tt>GG_NOTIFY_REPLY60</tt></td><td>Stan listy kontaktów przed GG 7.7</td></tr>
<tr class="tabf"><td><tt>0x0014</tt></td><td><tt>GG_NEED_EMAIL</tt></td><td>Logowanie powiodło się, ale powinniśmy uzupełnić adres e-mail w katalogu publicznym</td></tr>
<tr class="tabf2"><td><tt>0x0016</tt></td><td><tt>GG_LOGIN_HASH_TYPE_INVALID</tt></td><td>Dany rodzaj hashowania hasła jest nieobsługiwany przez serwer</td></tr>
<tr class="tabf2"><td><tt>0x0017</tt></td><td><tt>GG_STATUS77</tt></td><td>Zmiana stanu przed GG 8.0</td></tr>
<tr class="tabf2"><td><tt>0x0018</tt></td><td><tt>GG_NOTIFY_REPLY77</tt></td><td>Stan listy kontaktów przed GG 8.0</td></tr>
<tr class="tabf"><td><tt>0x001f</tt></td><td><tt>GG_DCC7_INFO</tt></td><td></td></tr>
<tr class="tabf"><td><tt>0x0020</tt></td><td><tt>GG_DCC7_NEW</tt></td><td>Informacje o chęci nawiązania połączenia DCC</td></tr>
<tr class="tabf"><td><tt>0x0021</tt></td><td><tt>GG_DCC7_ACCEPT</tt></td><td>Zaakceptowanie połączenia DCC</td></tr>
<tr class="tabf"><td><tt>0x0022</tt></td><td><tt>GG_DCC7_REJECT</tt></td><td>Odrzucenie połączenia DCC</td></tr>
<tr class="tabf"><td><tt>0x0023</tt></td><td><tt>GG_DCC7_ID_REPLY</tt></td><td></td></tr>
<tr class="tabf"><td><tt>0x0025</tt></td><td><tt>GG_DCC7_ABORTED</tt></td><td></td></tr>
<tr class="tabf"><td><tt>0x0027</tt></td><td><tt>GG_XML_EVENT</tt></td><td>Odebrano wiadomość systemową</td></tr>
<tr class="tabf2"><td><tt>0x002a</tt></td><td><tt>GG_STATUS80BETA</tt></td><td>Zmiana stanu przed Nowym Gadu-Gadu</td></tr>
<tr class="tabf"><td><tt>0x002b</tt></td><td><tt>GG_NOTIFY_REPLY80BETA</tt></td><td>Stan listy kontaktów przed Nowym Gadu-Gadu</td></tr>
<tr class="tabf"><td><tt>0x002c</tt></td><td><tt>GG_XML_ACTION</tt></td><td></td></tr>
<tr class="tabf"><td><tt>0x002e</tt></td><td><tt>GG_RECV_MSG80</tt></td><td>Przychodząca wiadomość</td></tr>
<tr class="tabf"><td><tt>0x0030</tt></td><td><tt>GG_USERLIST_REPLY80</tt></td><td>Odpowiedź listy kontaktów na serwerze</td></tr>
<tr class="tabf"><td><tt>0x0035</tt></td><td><tt>GG_LOGIN_OK80</tt></td><td>Logowanie powiodło się</td></tr>
<tr class="tabf"><td><tt>0x0036</tt></td><td><tt>GG_STATUS80</tt></td><td>Zmiana stanu</td></tr>
<tr class="tabf"><td><tt>0x0037</tt></td><td><tt>GG_NOTIFY_REPLY80</tt></td><td>Stan listy kontaktów</td></tr>
</table>

<hr />

<a name="ch2"></a>
<h2>2. Usługi HTTP</h2>

<a name="ch2.1"></a>
<h3>2.1. Format danych</h3>

<p>
Komunikacja z <tt>appmsg.gadu-gadu.pl</tt> metodą <tt>GET</tt> HTTP/1.0
została opisana w poprzednim rozdziale, pozostałe pakiety używają 
<tt>POST</tt> dla HTTP/1.0, a w odpowiedzi 1.1. Mają one postać:
</p>

<div class="http">
<pre>POST <b>ŚCIEŻKA</b> HTTP/1.0
Host: <b>HOST</b>
Content-Type: application/x-www-form-urlencoded
User-Agent: <b>AGENT</b>
Content-Length: <b>DŁUGOŚĆ</b>
Pragma: no-cache

<b>DANE</b></pre>
</div>

<p>
Gdzie <tt><b>AGENT</b></tt> to nazwa przeglądarki (na przykład <tt>Mozilla/4.0
(compatible; MSIE 5.0; Windows 98)</tt> lub inne, wymienione w rozdziale
<a href="#ch1.2">1.2</a>), <tt><b>DŁUGOŚĆ</b></tt> to długość bloku
<tt><b>DANE</b></tt> w znakach.
</p>

<p>
Jeśli będzie mowa o wysyłaniu danych do serwera, to chodzi o cały powyższy
pakiet, opisane zostaną tylko: <tt><b>HOST</b></tt>, <tt><b>ŚCIEŻKA</b></tt>
i <tt><b>DANE</b></tt>. Pakiet jest wysyłany na port 80. Gdy mowa o wysyłaniu
pól zapytania, mowa o <tt><b>DANE</b></tt> o wartości:
</p>

<div class="http">
<pre>pole1=wartość1&amp;pole2=wartość2&amp;...</pre>
</div>

<p>
Pamiętaj o zmianie kodowania na CP1250 i zakodowaniu danych do postaci URL
(na przykład funkcją typu <tt>urlencode</tt>).
</p>

<p>
Odpowiedzi serwera na powyższe zapytania mają mniej więcej postać:
</p>

<div class="http">
<pre>HTTP/1.1 200 OK
Server: Microsoft-IIS/5.0
Date: Mon, 01 Jul 2002 22:30:31 GMT
Connection: Keep-Alive
Content-Length: <b>DŁUGOŚĆ</b>
Content-Type: text/html
Set-Cookie: <b>COOKIE</b>
Cache-control: private

<b>ODPOWIEDŹ</b></pre>
</div>

<p>
Nagłówki nie są dla nas ważne. Można zauważyć tylko to, że czasami serwer
ustawia <tt><b>COOKIE</b></tt> np. &bdquo;<tt>ASPSESSIONIDQQGGGLJC=CAEKMBGDJCFBEOKCELEFCNKH; path=/</tt>&rdquo;. Pisząc dalej, że serwer &bdquo;odpowie wartością&rdquo; mowa
tylko o polu <b>ODPOWIEDŹ</b>. Kodowanie znaków w odpowiedzi to CP1250.
</p>

<hr />

<a name="ch2.2"></a>

<h3>2.2. Tokeny</h3> 

<p>
Prawdopodobnie ze względu na nadużycia i wykorzystywanie automatów
rejestrujących do polowań na &bdquo;złote numery GG&rdquo;, wprowadzono konieczność
autoryzacji za pomocą tokenu. Każda operacja zaczyna się od pobrania tokenu
z serwera, wyświetlenia użytkownikowi, odczytaniu jego wartości i wysłania
zapytania z identyfikatorem i wartością tokenu. Pobranie tokenu wygląda 
następująco:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td width="20%"><b>Pole nagłówka</b></td><td width="80%"><b>Wartość</b></td></tr>
<tr class="tabf"><td><tt>HOST</tt></td><td><tt>register.gadu-gadu.pl</tt></td></tr>
<tr class="tabf"><td><tt>ŚCIEŻKA</tt></td><td><tt>/appsvc/regtoken.asp</tt></td></tr>
</table>

<p>
Nie są wysyłane żadne parametry. Przykład:
</p>

<div class="http">
<pre>POST /appsvc/regtoken.asp HTTP/1.0
Host: register.gadu-gadu.pl
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/4.0 (compatible; MSIE 5.0; Windows 98)
Content-Length: 0
Pragma: no-cache
</pre>
</div>

<p>
Serwer w odpowiedzi odeśle:
</p>

<div class="http">
<pre><b>SZEROKOŚĆ WYSOKOŚĆ DŁUGOŚĆ
IDENTYFIKATOR
ŚCIEŻKA</b></pre></div>

<p>
Gdzie <tt><b>SZEROKOŚĆ</b></tt> i <tt><b>WYSOKOŚĆ</b></tt> opisują wymiary
obrazka z wartością tokenu, <tt><b>DŁUGOŚĆ</b></tt> mówi ile znaków zawiera
token, <tt><b>IDENTYFIKATOR</b></tt> jest identyfikatorem tokenu (tylko do
niego pasuje wartość tokenu), a <tt><b>ŚCIEŻKA</b></tt> to ścieżka do skryptu
zwracającego obrazek z wartością tokenu. Przykładowa odpowiedź:
</p>

<div class="http">
<pre>60 24 6
06C05A44
http://register.gadu-gadu.pl/appsvc/tokenpic.asp</pre></div>

<p>
Możemy teraz pobrać metodą GET z podanej ścieżki obrazek z tokenem, doklejając
do ścieżki parametr <tt><b>tokenid</b></tt> o wartości będącej identyfikatorem
uzyskanym przed chwilą. Adres obrazka z wartością tokenu dla powyższego
przykładu to:
</p>

<div class="example">
<pre>http://register.gadu-gadu.pl/appsvc/tokenpic.asp?tokenid=06C05A44</pre>
</div>

<p>
Pobrany obrazek (w tej chwili jest w formacie JPEG, ale prawdopodobnie może
się to zmienić na dowolny format obsługiwany domyślnie przez system Windows)
najlepiej wyświetlić użytkownikowi, prosząc o podanie wartości na nim
przedstawionej. Będzie ona niezbędna do przeprowadzenia kolejnych operacji.
</p>

<hr />

<a name="ch2.3"></a>

<h3>2.3. Rejestracja konta</h3>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td width="20%"><b>Pole nagłówka</b></td><td width="80%"><b>Wartość</b></td></tr>
<tr class="tabf"><td><tt>HOST</tt></td><td><tt>register.gadu-gadu.pl</tt></td></tr>
<tr class="tabf"><td><tt>ŚCIEŻKA</tt></td><td><tt>/appsvc/fmregister3.asp</tt></td></tr>
</table>

<p></p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td width="20%"><b>Wysyłamy pole</b></td><td width="80%"><b>Znaczenie</b></td></tr>
<tr class="tabf"><td><tt>pwd</tt></td><td>hasło dla nowego numeru</td></tr>
<tr class="tabf"><td><tt>email</tt></td><td>e-mail na który będzie przesyłane przypomnienie hasła</td></tr>
<tr class="tabf"><td><tt>tokenid</tt></td><td>identyfikator tokenu</td></tr>
<tr class="tabf"><td><tt>tokenval</tt></td><td>wartość tokenu</td></tr>
<tr class="tabf"><td><tt>code</tt></td><td>hash liczony z pól <tt>email</tt> i <tt>pwd</tt>. Algorytmu szukaj w źródłach libgadu w <tt>lib/common.c</tt></td></tr>
</table>

<p>
Przykład:
</p>

<div class="http">
<pre>POST /appsvc/fmregister3.asp HTTP/1.0
Host: register.gadu-gadu.pl
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/4.0 (compatible; MSIE 5.0; Windows 98)
Content-Length: 76
Pragma: no-cache
		
pwd=sekret&amp;email=abc&#64;xyz.pl<!-- &amp;qa=5~Maria -->&amp;tokenid=06C05A44&amp;tokenval=e94d56&amp;code=1104465363</pre>
</div>

<p>
Jeśli wszystko przebiegło poprawnie, serwer odpowie:
</p>

<div class="http">
<pre>Tokens okregisterreply_packet.reg.dwUserId=<b>UIN</b></pre>
</div>

<p>
Gdzie <tt><b>UIN</b></tt> to nowy numer, który właśnie otrzymaliśmy.
</p>

<p>
Jeśli został podany nieprawidłowy token, serwer odpowie:
</p>

<div class="http">
<pre>bad_tokenval</pre>
</div>

<hr />

<a name="ch2.4"></a>
<h3>2.4. Usunięcie konta</h3>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td width="20%"><b>Pole nagłówka</b></td><td width="80%"><b>Wartość</b></td></tr>
<tr class="tabf"><td><tt>HOST</tt></td><td><tt>register.gadu-gadu.pl</tt></td></tr>
<tr class="tabf"><td><tt>ŚCIEŻKA</tt></td><td><tt>/appsvc/fmregister3.asp</tt></td></tr>
</table>

<p></p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td width="20%"><b>Wysyłamy pole</b></td><td width="80%"><b>Znaczenie</b></td></tr>
<tr class="tabf"><td><tt>fmnumber</tt></td><td>usuwany numer</td></tr>
<tr class="tabf"><td><tt>fmpwd</tt></td><td>hasło</td></tr>
<tr class="tabf"><td><tt>delete</tt></td><td>wartość &bdquo;<tt>1</tt>&rdquo;</td></tr>
<tr class="tabf"><td><tt>pwd</tt></td><td>losowa liczba</td></tr>
<tr class="tabf"><td><tt>email</tt></td><td>wartość &bdquo;<tt>deletedaccount@gadu-gadu.pl</tt>&rdquo;</td></tr>
<tr class="tabf"><td><tt>tokenid</tt></td><td>identyfikator tokenu</td></tr>
<tr class="tabf"><td><tt>tokenval</tt></td><td>wartość tokenu</td></tr>
<tr class="tabf"><td><tt>code</tt></td><td>hash liczony z pól <tt>pwd</tt> i <tt>email</tt></td></tr>
</table>

<p>
Przykład:
</p>

<div class="http">
<pre>POST /appsvc/fmregister2.asp HTTP/1.0
Host: register.gadu-gadu.pl
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/4.0 (compatible; MSIE 5.0; Windows 98)
Content-Length: 137
Pragma: no-cache
		
fmnumber=4969256&amp;fmpwd=haslo&amp;delete=1&amp;email=deletedaccount@gadu-gadu.pl&amp;pwd=%2D38
8046464&amp;tokenid=06C05A44&amp;tokenval=e94d56&amp;code=1483497094</pre>
</div>

<p>
Jeśli wszystko przebiegło poprawnie, serwer odpowie:
</p>

<div class="http">
<pre>reg_success:<b>UIN</b></pre>
</div>

<p>
Gdzie <tt><b>UIN</b></tt> to numer, który skasowaliśmy.
</p>

<hr />

<a name="ch2.5"></a>
<h3>2.5. Zmiana hasła</h3>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td width="20%"><b>Pole nagłówka</b></td><td width="80%"><b>Wartość</b></td></tr>
<tr class="tabf"><td><tt>HOST</tt></td><td><tt>register.gadu-gadu.pl</tt></td></tr>
<tr class="tabf"><td><tt>ŚCIEŻKA</tt></td><td><tt>/appsvc/fmregister3.asp</tt></td></tr>
</table>

<p></p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td width="20%"><b>Wysyłamy pole</b></td><td width="80%"><b>Znaczenie</b></td></tr>
<tr class="tabf"><td><tt>fmnumber</tt></td><td>numer</td></tr>
<tr class="tabf"><td><tt>fmpwd</tt></td><td>stare hasło</td></tr>
<tr class="tabf"><td><tt>pwd</tt></td><td>nowe hasło</td></tr>
<tr class="tabf"><td><tt>email</tt></td><td>nowe adres e-email</td></tr>
<tr class="tabf"><td><tt>tokenid</tt></td><td>identyfikator tokenu</td></tr>
<tr class="tabf"><td><tt>tokenval</tt></td><td>wartość tokenu</td></tr>
<tr class="tabf"><td><tt>code</tt></td><td>hash liczony z pól <tt>pwd</tt> i <tt>email</tt></td></tr>
</table>

<p>
Jeśli wszystko przebiegło poprawnie, serwer odpowie:
</p>

<div class="http">
<pre>reg_success:<b>UIN</b></pre>
</div>

<hr />

<a name="ch2.6"></a>
<h3>2.6. Przypomnienie hasła pocztą</h3>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td width="20%"><b>Pole nagłówka</b></td><td width="80%"><b>Wartość</b></td></tr>
<tr class="tabf"><td><tt>HOST</tt></td><td><tt>retr.gadu-gadu.pl</tt></td></tr>
<tr class="tabf"><td><tt>ŚCIEŻKA</tt></td><td><tt>/appsvc/fmsendpwd3.asp</tt></td></tr>
</table>

<p></p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td width="20%"><b>Wysyłamy pole</b></td><td width="80%"><b>Znaczenie</b></td></tr>
<tr class="tabf"><td><tt>userid</tt></td><td>numer</td></tr>
<tr class="tabf"><td><tt>tokenid</tt></td><td>identyfikator tokenu</td></tr>
<tr class="tabf"><td><tt>tokenval</tt></td><td>wartość tokenu</td></tr>
<tr class="tabf"><td><tt>code</tt></td><td>hash liczony z pola <tt>userid</tt></td></tr>
</table>

<p>
Jeśli się udało, serwer odpowie:
</p>

<div class="http">
<pre>pwdsend_success</pre>
</div>

<hr />

<a name="ch3"></a>
<h2>3. Połączenia bezpośrednie</h2>

<a name="ch3.1"></a>
<h3>3.1. Nawiązanie połączenia</h3>

<p>
Połączenia bezpośrednie pozwalają przesyłać pliki lub prowadzić rozmowy
głosowe bez pośrednictwa serwera. Początkowe wersje Gadu-Gadu potrafiły
przesyłać bezpośrednio również wiadomości tekstowe, ale funkcjonalność
ta została zarzucona.
</p>

<p>
Dla każdego połączenia musimy zdobyć od serwera 8 bajtowy identyfikator.
Aby pobrać identyfikator należy użyć pakietu:
</p>

<div class="c">
<pre>#define GG_DCC7_ID_REQUEST 0x0023

struct gg_dcc7_id_request {
	int type;		<i>/* rodzaj transmisji */</i>
};</pre>
</div>

<p>
Pole <tt>type</tt> oznacza rodzaj transmisji:
</p>

<div class="c">
<pre>#define GG_DCC7_TYPE_VOICE 0x00000001	<i>/* Rozmowa głosowa (już nieużywane) */</i>
#define GG_DCC7_TYPE_FILE 0x00000004	<i>/* Przesyłanie plików */</i>
</pre>
</div>

<p>
Na co serwer odpowie:
</p>

<div class="c">
<pre>#define GG_DCC7_ID_REPLY 0x0023

struct gg_dcc7_id_reply {
	int type;	<i>/* Rodzaj transmisji */</i>
	long long id;	<i>/* przyznany identyfikator */</i>
};</pre>
</div>

<hr />

<a name="ch3.2"></a>
<h3>3.2. Przesyłanie plików</h3>

<div class="check">W rodzaju transmisji (type) GG_DCC7_TYPE_FILE</div>

<h4>3.2.1 GG_DCC7_TYPE_FILE - Jak powiadamiać, jak akceptować oraz jak odrzucać</h4>

<p>
Aby powiadomić o chęci przesłania pliku, należy wysłać następujący pakiet.
</p>

<div class="c">
<pre>#define GG_DCC7_NEW 0x0020

struct gg_dcc7_new {
	long long id;		<i>/* identyfikator połączenia */</i>
	int uin_from;		<i>/* numer nadawcy */</i>
	int uin_to;		<i>/* numer odbiorcy */</i>
	int type;		<i>/* rodzaj transmisji */</i>
	char filename[255];	<i>/* nazwa pliku */</i>
	long long size;		<i>/* rozmiar pliku */</i>
	char hash[20];		<i>/* hash SHA1 (już nieużywane 00 00 00) */</i>
};</pre>
</div>

<p>
Strona wywoływana po otrzymaniu pakietu GG_DCC7_NEW, może zaakceptować pobieranie pliku,
wysyła pakiet:
</p>

<div class="c">
<pre>#define GG_DCC7_ACCEPT 0x0021

struct gg_dcc7_accept {
	int uin;	<i>/* numer przyjmującego połączenie */</i>
	long long id;	<i>/* identyfikator połączenia */</i>
	int offset;	<i>/* offset przy wznawianiu transmisji */</i>
	int dunno1;	<i>/* 0x00000000 (na 99% kontynuacja offsetu) */</i>
};</pre>
</div>

<p>
Jeśli plik został już częściowo odebrany i chcemy wznowić przesyłanie,
w polu <tt>offset</tt> wystarczy podać ile bajtów już mamy, a odebrane
dane dopisać na końcu pliku.
</p>

<p>
Jeśli strona wywołana chce odrzucić plik wysyła pakiet:
</p>

<div class="c">
<pre>#define GG_DCC7_REJECT 0x0022

struct gg_dcc7_reject {
	int uin;	<i>/* Numer odrzucającego połączenie */</i>
	long long id;	<i>/* Identyfikator połączenia */</i>
	int reason;	<i>/* Powód rozłączenia */</i>
};</pre>
</div>

<p>
Dla pola <tt>reason</tt> znane są wartości:
</p>

<div class="c">
<pre>#define GG_DCC7_REJECT_BUSY	0x00000001	<i>/* Połączenie bezpośrednie już trwa, nie umiem obsłużyć więcej */</i>
#define GG_DCC7_REJECT_USER	0x00000002	<i>/* Użytkownik odrzucił połączenie */</i>
#define GG_DCC7_REJECT_VERSION	0x00000006	<i>/* Druga strona ma wersję klienta nieobsługującą połączeń bezpośrednich tego typu */</i>
</pre>
</div>

<p>
Przed akceptacją pliku przez stronę wywoływaną, użytkownik może przerwać
żądanie wysyłając pakiet:
</p>

<div class="c">
<pre>#define GG_DCC7_ABORT 0x0025
struct gg_dcc7_abort {
	long long id;		<i>/* identyfikator połączenia */</i>
	int uin_from;		<i>/* numer nadawcy */</i>
	int uin_to;		<i>/* numer odbiorcy */</i>
};</pre>
</div>

<p>
Strona wywoływana w takim przypadku powinna otrzymać pakiet:
</p>

<div class="c">
<pre>#define GG_DCC7_ABORTED 0x0025
struct gg_dcc7_aborted {
	long long id;		<i>/* identyfikator połączenia */</i>
};</pre>
</div>


<p>
Po zaakceptowaniu pliku, obie strony zaczynają nasłuchiwać na losowo wybranym porcie i
wysyłają pakiet GG_DCC7_INFO z informacjami potrzebnymi do połączenia.
</p>

<h4>3.2.2 relay.gadu-gadu.pl - 91.197.13.102 albo tajemniczy host w podsieci 91.197.12.0/22</h4>

<p>
Oba hosty łączą się również z relay.gadu-gadu.pl:80 aby uzyskać listę serwerów które mogą pośredniczyć
w wymianie plików.
</p>

<div class="c">
<pre>#define GG_DCC7_RELAY_REQUEST 0x0a
struct gg_dcc7_relay_req {
	int magic;	<i>/* 0x0a */</i>
	int len;	<i>/* długość całego pakietu */</i>
	long long id;	<i>/* identyfikator połączenia */</i>
	short dunno1;	<i>/* 0x01 0x00 */</i>
	short dunno2;	<i>/* 0x02 0x00 */</i>
};</pre>
</div>

<div class="check">
Czy wysyła zapytania DNS o relay.gadu-gadu.pl U mnie łączy się z 91.197.13.102, zapytań nie widziałem (cache?)
</div>

<div class="check">
Tak naprawdę z relay.gadu-gadu.pl łączą się dwa razy.
Za pierwszym razem łączą się wysyłając w dunno1: 08 00.
Odpowiada też dwoma rekordami, ale w port jest 00 00
</div>

<p>
Przykładowe pytanie o serwery dla połączenia 0x160600000bd4
</p>

<div class="example">
<pre>
0000  0a 00 00 00 14 00 00 00 d4 0b 00 00 06 16 00 00
0010  01 00 02 00
</pre>
</div>

<p>
Serwer odpowiada:
</p>

<div class="c">
<pre>#define GG_DCC7_RELAY_REPLY 0x0b
struct gg_dcc7_relay_reply {
	int magic;	<i>/* 0x0b */</i>
	int len;	<i>/* długość całego pakietu */</i>
	int rcount;	<i>/* prawdopodobnie ilość pośredniczących serwerów */</i>
	struct {
		int ip;		<i>/* adres ip serwera */</i>
		short port;	<i>/* port serwera */</i>
		char family;	<i>/* rodzina adresów (na końcu?!) AF_INET=2 */</i>
	} proxies[rcount];
};</pre>

</div>

<p>Przykładowa odpowiedź serwera zawierająca 2 rekordy:</p>
<ol>
  <li>91.197.13.104:80</li>
  <li>91.197.13.104:443</li>
</ol>

<div class="example">
<pre>
0000  0b 00 00 00 1a 00 00 00 02 00 00 00 5b c5 0d 68
0010  50 00 02 5b c5 0d 68 bb 01 02
</pre>
</div>

<p></p>

<h4>3.2.3 GG_DCC7_INFO - Jak się odnaleźć w mroku</h4>

<div class="c">
<pre>#define GG_DCC7_INFO 0x001f

struct gg_dcc7_info {
	int uin;	<i>/* numer nadawcy */</i>
	int type;	<i>/* sposób połączenia */</i>
	long long id;	<i>/* identyfikator połączenia */</i>
	char info[64];	<i>/* informacje o połączeniu */</i>
};</pre>
</div>

<div class="check">Rodzielić info na info1, info2</div>

<p>
W polu <tt>type</tt> sposób połączenia:
</p>

<div class="c">
<pre>#define GG_DCC7_TYPE_P2P 0x00000001	<i>/* Połączenie bezpośrednie */</i>
#define GG_DCC7_TYPE_SERVER 0x00000002	<i>/* Połączenie przez serwer */</i>
</pre>
</div>

<p>Dla połączeń bezpośrednich:</p>
<ul>
 <li>pierwsze 32bajty pola <tt>info</tt> to <i>IP &lt;SPACJA&gt; PORT</i></li>
 <li>drugie 32bajty pola <tt>info</tt> to ip oraz port w innej postaci, niestety nie mamy informacji o algorytmie :)</li>
</ul>

<p>
Przykładowa zawartość pola <tt>info</tt> dla 10.0.0.2:22563
</p>

<div class="example">
<pre>
0000   31 30 2e 30 2e 30 2e 32 20 32 32 35 36 33 00 00  10.0.0.2 22563..
0010   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0020   31 37 36 34 36 38 34 38 34 00 00 00 00 00 00 00  176468484.......
0030   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
</pre>
</div>

<p>
Po udanym połączeniu na podany adres w GG_DCC7_INFO wysyłamy pakiet powitalny:
</p>

<div class="c">
<pre>struct gg_dcc7_welcome_p2p {
	long long id;	<i>/* identyfikator połączenia */</i>
};</pre>
</div>

<p>
Druga strona powinna odpowiedzieć tym samym. Teraz już możemy albo wysyłać albo odbierać plik.
</p>
<div class="check">
Z powodu tego że obie strony łączą się w tym samym momencie możliwy jest wyścig.
Z tego co zauważyłem gdy jednak ze stron zorientuje się że na innym połączeniu dostaliśmy już ten id,
to połączenie jest zrywane - ale czy taki sposób rozwiązywania nie powoduje możliwych wyścigów?
</div>

<p>Dla połączeń przez serwer:<br/>
- pierwsze 32bajty pola <tt>info</tt> to GG<i>id</i>CH<i>numerek</i><br/><br/>
Gdzie: <br/>
<tt>id</tt> to identyfikator połączenia zapisany w cyferkach ASCII<br/>
<tt>numerek</tt> TBD
</p>

<div class="warn">
<pre>
GG7.7 wysyła: GG<i>id</i><b>SH</b><i>numerek</i>
Protokół jest inny, i raczej nie będzie działać.
</pre>
</div>

<p>
Przykładowa zawartość pola <tt>info</tt> dla połączenia 0x00000a0600000b27<br/>
<br/>
$ echo 'ibase=16; 00000A0600000B27' | bc <br/>
11020886084391
</p>

<div class="example">
<pre>
0000   47 47 31 31 30 32 30 38 38 36 30 38 34 33 39 31  GG11020886084391
0010   43 48 36 39 36 32 00 00 00 00 00 00 00 00 00 00  CH6962..........
0020   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0030   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
</pre>
</div>

<p>
Po połączeniu do serwera pośredniczącego wysyłamy pakiet powitalny:
</p>

<div class="c">
<pre>struct gg_dcc7_welcome_server {
	int dunno1;	<i>/* 0xc0debabe */</i>
	long long id;	<i>/* identyfikator połączenia */</i>
};</pre>
</div>

<p>
Serwer powinien odpowiedzieć tym samym. Teraz już możemy albo wysyłać albo odbierać plik.
</p>

<hr />

<a name="ch3.3"></a>
<h3>3.3. Rozmowy głosowe</h3>

<div class="check">
ZTCP to leci po SIP
</div>

<div class="check">
<p>
Aby powiadomić o chęci rozmowy głosowej należy wysłać pakiet:
</p>

<div class="c">
<pre>#define GG_DCC_REQUEST_VOICE 0x0002

struct gg_dcc_request {
	int type;	<i>/* GG_DCC_REQUEST_VOICE */</i>
};</pre>
</div>

<p>
Strona wywołana może potwierdzić chęć przeprowadzenia rozmowy za pomocą
pakietu:
</p>

<div class="c">
<pre>#define GG_DCC_VOICE_ACK 0x01

struct gg_dcc_voice_ack {
	char type;	<i>/* GG_DCC_VOICE_ACK */</i>
};</pre>
</div>

<p>
Jeśli strona wywołana chce odrzucić rozmowę głosową, zrywa połączenie.
Mimo tego, strona wywołująca nie powinna ignorować wartości potwierdzenia.
</p>

<p>
Następnie przesyłane są próbki dźwiękowe kodowane microsoftowym wariantem
GSM. Pod systemem Windows wystarczy użyć standardowego kodeka, pod innymi
można skorzystać z biblioteki
<a href="http://kbs.cs.tu-berlin.de/~jutta/toast.html">libgsm</a> z opcją
WAV49. Pakiet danych wygląda następująco:
</p>

<div class="c">
<pre>#define GG_DCC_VOICE_DATA 0x03

struct gg_dcc_voice_data {
	char type;	<i>/* GG_DCC_VOICE_DATA */</i>
	int length;	<i>/* długość pakietu */</i>
	char data[];	<i>/* dane */</i>
};</pre>
</div>

<p>
W celu zakończenia rozmowy głosowej, zamiast powyższej ramki wysyła się:
</p>

<div class="c">
<pre>#define GG_DCC_VOICE_TERMINATE 0x04

struct gg_dcc_voice_terminate {
	char type;	<i>/* GG_DCC_VOICE_TERMINATE */</i>
};</pre>
</div>

<p>
Do wersji 5.0.5 w jednym pakiecie było umieszczone 6 ramek GSM (<i>6 * 32,5 =
195 bajtów</i>), a począwszy od tej wersji przesyła się po 10 ramek GSM,
poprzedzając je bajtem zerowym (<i>1 + 10 * 32,5 = 326 bajtów</i>).
</p>
</div>

<hr />

<a name="ch4"></a>
<h2>4. Autorzy</h2>

<p>
Lista autorów tego tekstu znajduje się poniżej. Ich adresy e-mail <b>nie
służą</b> do zadawania pytań o podstawy programowania albo jak się
połączyć z serwerem i co zrobić dalej. Jeśli masz pytania dotyczące protokołu,
napisz na listę dyskusyjną
<a href="http://lists.ziew.org/mailman/listinfo/libgadu-devel">libgadu-devel</a>.
</p>

<ul>
	<li><b>Wojtek Kaniewski</b> (wojtekka%irc.pl): pierwsza wersja opisu,
	poprawki, utrzymanie wszystkiego w porządku.</li>
	<li><b>Robert J. Woźny</b> (speedy%atman.pl): opis nowości w protokole
	GG 4.6, poprawki.</li>
	<li><b>Tomasz Jarzynka</b> (tomee%cpi.pl): badanie timeoutów.</li>
	<li><b>Adam Ludwikowski</b> (adam.ludwikowski%wp.pl): wiele poprawek,
	wersje klientów, rozszerzone wiadomości, powody nieobecności.</li>
	<li><b>Marek Kozina</b> (klith%hybrid.art.pl): czas otrzymania
	wiadomości.</li>
	<li><b>Rafał Florek</b> (raf%regionet.regionet.pl): opis połączeń
	konferencyjnych.</li>
	<li><b>Igor Popik</b> (igipop%wsfiz.edu.pl): klasy wiadomości przy
	odbieraniu zakolejkowanej.</li>
	<li><b>Rafał Cyran</b> (ajron%wp.pl): informacje o remote_port,
	rodzaje potwierdzeń przy ctcp, GG_LOGIN_EXT.</li>
	<li><b>Piotr Mach</b> (pm%gadu-gadu.com): ilość kontaktów, pełna
	skrzynka, pusta lista, maska audio, usługi HTTP, GG_LOGIN_EXT.</li>
	<li><b>Adam Czyściak</b> (acc%interia.pl): potwierdzenie wiadomości
	GG_CLASS_ACK.</li>
	<li><b>Kamil Dębski</b> (kdebski%kki.net.pl): czas w stanach
	opisowych.</li>
	<li><b>Paweł Piwowar</b> (alfapawel%go2.pl): format czasu.</li>
	<li><b>Tomasz Chiliński</b> (chilek%chilan.com): nowości w 5.0.2.</li>
	<li><b>Radosław Nowak</b> (rano%ranosoft.net): uzupełnienie statusu
	opisowego, wersja 5.0.3.</li>
	<li><b>Walerian Sokołowski</b>: pierwsza wersja opisu protokołu
	bezpośrednich połączeń.</li>
	<li><b>Nikodem</b> (n-d%tlen.pl): flagi rodzaju użytkownika.</li>
	<li><b>Adam Wysocki</b> (gophi%ekg.chmurka.net): poprawki, utrzymanie 
	wszystkiego w porządku, GG_XML_EVENT.</li>
	<li><b>Marcin Krupowicz</b> (marcin.krupowicz%gmail.com): informacja na 
	temat tego, że pakiet GG_LOGIN_OK nie zawsze jest zerowej długości.</li>
	<li><b>Jakub Zawadzki</b> (darkjames%darkjames.ath.cx): nowości w
	7.x i 8.x.</li>
	<li><b>Krystian Kołodziej</b> (krystiankolodziej%gmail.com): znaczenie
	GG_DISCONNECT_ACK.</li>
</ul>

<hr />

<font color="silver">
$Id$
</font>

</td></tr></table>
</center>

</body>
</html>
